package server

import (
	"fmt"
	"log"
	"net"
	"net/http"
	"sync"
)

// HttpRequestTracker will track all open http requests, allowing any open
// requests to be logged on shutdown.
type HttpRequestTracker struct {
	activeRequests map[string]int
	mu             sync.Mutex
}

// Middleware to track active requests
func (hrt *HttpRequestTracker) trackRequests(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		requestID := fmt.Sprintf("%s %s", r.Method, r.URL.Path)
		hrt.mu.Lock()
		if hrt.activeRequests == nil {
			hrt.activeRequests = make(map[string]int)
		}
		hrt.activeRequests[requestID]++
		hrt.mu.Unlock()

		defer func() {
			hrt.mu.Lock()
			hrt.activeRequests[requestID]--
			if hrt.activeRequests[requestID] == 0 {
				delete(hrt.activeRequests, requestID)
			}
			hrt.mu.Unlock()
		}()

		next.ServeHTTP(w, r)
	})
}

// Function to print active requests
func (hrt *HttpRequestTracker) logActiveRequests() {
	hrt.mu.Lock()
	defer hrt.mu.Unlock()
	for request, count := range hrt.activeRequests {
		if count > 0 {
			s := fmt.Sprintf("Active request at shutdown: %s, count: %d", request, count)
			panic(s)
			fmt.Printf(s)
			log.Printf(s)
		}
	}
}

// launchAPI sets up the HTTP API endpoints and starts the HTTP server.
// This function initializes the API routes and starts the HTTP server.
func (gcas *GCAServer) launchAPI() {
	// Attach all of the handlers to the mux. The following lines generated by GPT4.
	var hrt HttpRequestTracker
	gcas.mux.Handle("/api/v1/all-device-stats", hrt.trackRequests(http.HandlerFunc(gcas.AllDeviceStatsHandler)))
	gcas.mux.Handle("/api/v1/authorized-servers", hrt.trackRequests(http.HandlerFunc(gcas.AuthorizedServersHandler)))
	gcas.mux.Handle("/api/v1/authorize-equipment", hrt.trackRequests(http.HandlerFunc(gcas.AuthorizeEquipmentHandler)))
	gcas.mux.Handle("/api/v1/equipment", hrt.trackRequests(http.HandlerFunc(gcas.EquipmentHandler)))
	gcas.mux.Handle("/api/v1/equipment-migrate", hrt.trackRequests(http.HandlerFunc(gcas.EquipmentMigrateHandler)))
	gcas.mux.Handle("/api/v1/register-gca", hrt.trackRequests(http.HandlerFunc(gcas.RegisterGCAHandler)))
	gcas.mux.Handle("/api/v1/recent-reports", hrt.trackRequests(http.HandlerFunc(gcas.RecentReportsHandler)))
	gcas.mux.Handle("/api/v1/geo-stats", hrt.trackRequests(http.HandlerFunc(GeoStatsHandler)))
	gcas.httpServer.RegisterOnShutdown(hrt.logActiveRequests)

	// Create a listener. In prod it's a specfic port, during testing it's
	// ":0". Because we don't know what the port is during testing, we need
	// to build the listener manually so that we can grab the port from it.
	listener, err := net.Listen("tcp", gcas.httpServer.Addr)
	if err != nil {
		panic("unable to launch gca api")
	}
	gcas.httpPort = uint16(listener.Addr().(*net.TCPAddr).Port)

	// Launch the background thread that keeps the API running. The
	// listener gets handed off to the httpServer, which will be
	// responsible for closing the listener, therefore the listener does
	// not need to be closed here. If the Launch fails, the listener will
	// never get attached to the httpServer, which means we will have to
	// close it manually.
	err = gcas.tg.Launch(func() {
		gcas.logger.Info("Starting HTTP server on ", gcas.httpServer.Addr)
		if err := gcas.httpServer.Serve(listener); err != nil && err != http.ErrServerClosed {
			gcas.logger.Fatal("Could not start HTTP server: ", err)
		}
	})
	if err != nil {
		listener.Close()
	}
}
